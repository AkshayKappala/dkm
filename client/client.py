import socket
import os
import struct
import pickle
import hashlib
import logging
import time  # Import time for timeout handling
from client.encryption.aes_encryption import aes_encrypt
from client.encryption.dwt_processor import process_image
from shared.crypto_utils import derive_key, sha256_hash, sha512_hash
from shared.key_rotation_manager import KeyRotationManager
from client.utils.file_utils import read_image

SERVER_ADDRESS = ('192.168.233.129', 12345)

sent_directory = "sent"
key_rotation_manager = KeyRotationManager()
password = "secure_password"

client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client_socket.settimeout(5)  # Set a 5-second timeout for socket operations

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def calculate_checksum(data):
    return hashlib.sha256(data).hexdigest()

def send_file_to_server(file_data):
    try:
        client_socket.sendall(file_data)
        ack = client_socket.recv(3)
        if ack == b"ACK":
            logging.info("File sent successfully.")
            return True
        else:
            logging.warning("No acknowledgment received.")
            return False
    except socket.timeout:
        logging.error("Timeout occurred while sending file.")
        return False
    except Exception as e:
        logging.error(f"Error sending file: {e}")
        return False

try:
    logging.info("Connecting to server at %s:%d", *SERVER_ADDRESS)
    client_socket.connect(SERVER_ADDRESS)
    
    files_to_send = sorted(read_image(sent_directory))
    if not files_to_send:
        logging.warning("No files found in the 'sent' directory to send.")
        raise Exception("No files to send")
    
    for filename in files_to_send:
        file_path = os.path.join(sent_directory, filename)
        retries = 3  # Retry up to 3 times for each file
        for attempt in range(retries):
            try:
                logging.info("Processing file: %s (Attempt %d)", filename, attempt + 1)
                should_rotate, similarity, reason, new_password = key_rotation_manager.should_rotate_key(file_path)
                logging.info("Key rotation decision for %s: %s (Reason: %s)", filename, should_rotate, reason)
                
                if should_rotate:
                    password = new_password  # Use the new password generated by Kyber
                    logging.info("Rotating key for file: %s", filename)
                    password_bytes = password.encode('utf-8')
                    password_length = len(password_bytes)
                    client_socket.sendall(b'\x01' + struct.pack('>I', password_length) + password_bytes)

                    # Wait for acknowledgment from the server after sending the new key
                    ack = client_socket.recv(3)
                    if ack != b"ACK":
                        logging.error("Failed to receive acknowledgment for key rotation. Aborting.")
                        break

                filename_bytes = filename.encode('utf-8')
                filename_length = len(filename_bytes)
                client_socket.sendall(b'\x02' + struct.pack('>I', filename_length) + filename_bytes)

                with open(file_path, 'rb') as file:
                    data = file.read()
                
                serialized_data = pickle.dumps(data)
                encrypted_data = aes_encrypt(serialized_data, password)  # Use the updated password
                logging.info("File %s encrypted successfully.", filename)
                
                data_length = len(encrypted_data)
                client_socket.sendall(struct.pack('>Q', data_length))  # Use 8 bytes for length
                if send_file_to_server(encrypted_data):
                    break  # Exit retry loop if file is sent successfully
                else:
                    logging.warning("Retrying file transfer for %s...", filename)

            except socket.timeout:
                logging.error("Timeout occurred for file %s. Retrying...", filename)
            except Exception as e:
                logging.error("Error processing file %s: %s", filename, e)
                break  # Exit retry loop on non-recoverable error

    logging.info("File transfer complete.")
    
    # Send end-of-transfer signal
    client_socket.sendall(b'\x03')  # Send end-of-transfer flag
    logging.info("End-of-transfer signal sent.")

    try:
        ack = client_socket.recv(3)
        if ack == b"ACK":
            logging.info("Server acknowledged end-of-transfer.")
        else:
            logging.warning("Unexpected response from server after end-of-transfer.")
    except ConnectionResetError:
        logging.info("Server closed the connection after acknowledging end-of-transfer.")
    except Exception as e:
        logging.error(f"Error waiting for server acknowledgment after end-of-transfer: {e}")

    # No need to wait for further messages; close the socket
    logging.info("Closing client socket after end-of-transfer.")

except Exception as e:
    logging.error("Error occurred during client operation: %s", e)
finally:
    try:
        if client_socket:
            client_socket.shutdown(socket.SHUT_RDWR)
            client_socket.close()
            logging.info("Client socket closed.")
    except:
        logging.error("Error closing client socket.")
